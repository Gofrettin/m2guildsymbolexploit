#include "pch.h"
#include "NetStream.h"
#include "tea.h"

void CNetworkStream::SetSecurityMode(bool isSecurityMode, const char* c_szTeaKey)
{
	memcpy(m_szEncryptKey, c_szTeaKey, 16);
	memcpy(m_szDecryptKey, c_szTeaKey, 16);
}

void CNetworkStream::SetSecurityMode(bool isSecurityMode, const char* c_szTeaEncryptKey, const char* c_szTeaDecryptKey)
{
	memcpy(m_szEncryptKey, c_szTeaEncryptKey, 16);
	memcpy(m_szDecryptKey, c_szTeaDecryptKey, 16);
}

bool CNetworkStream::IsSecurityMode() const
{
	switch (m_security_type)
	{
	case SECURITY_TYPE_XTEA:
		return true;
	case SECURITY_TYPE_CIPHER:
		return m_cipher.activated();
	default:
		return false;
	}
}

void CNetworkStream::SetRecvBufferSize(int32_t recvBufSize)
{
	if (m_recvBuf)
	{
		if (m_recvBufSize > recvBufSize)
			return;

		delete [] m_recvBuf;
		delete [] m_recvTEABuf;
	}
	m_recvBufSize = recvBufSize;
	m_recvBuf = new char[m_recvBufSize];
	m_recvTEABufSize = ((m_recvBufSize >> 3) + 1) << 3;
	m_recvTEABuf = new char[m_recvTEABufSize];
}

void CNetworkStream::SetSendBufferSize(int32_t sendBufSize)
{
	if (m_sendBuf)
	{
		if (m_sendBufSize > sendBufSize)
			return;

		delete [] m_sendBuf;
		delete [] m_sendTEABuf;
	}

	m_sendBufSize = sendBufSize;
	m_sendBuf = new char[m_sendBufSize];
	m_sendTEABufSize = ((m_sendBufSize >> 3) + 1) << 3;
	m_sendTEABuf = new char[m_sendTEABufSize];
}

bool CNetworkStream::__RecvInternalBuffer()
{
	if (m_recvBufOutputPos > 0)
	{
		const int32_t recvBufDataSize = m_recvBufInputPos - m_recvBufOutputPos;
		if (recvBufDataSize > 0)
		{
			memmove(m_recvBuf, m_recvBuf + m_recvBufOutputPos, recvBufDataSize);
		}

		m_recvBufInputPos -= m_recvBufOutputPos;
		m_recvBufOutputPos = 0;
	}

	if (m_security_type == SECURITY_TYPE_CIPHER)
	{
		const int32_t restSize = m_recvBufSize - m_recvBufInputPos;
		if (restSize > 0)
		{
			const int32_t recvSize = recv(m_sock, m_recvBuf + m_recvBufInputPos, m_recvBufSize - m_recvBufInputPos, 0);

			if (recvSize < 0)
			{
				const int32_t error = WSAGetLastError();

				if (error != WSAEWOULDBLOCK)
				{
					return false;
				}
			}
			else if (recvSize == 0)
			{
				return false;
			}

			if (IsSecurityMode())
			{
				m_cipher.Decrypt(m_recvBuf + m_recvBufInputPos, recvSize);
			}

			m_recvBufInputPos += recvSize;
		}
	}
	else if(m_security_type == SECURITY_TYPE_XTEA)
	{
		int32_t restSize = min(m_recvTEABufSize - m_recvTEABufInputPos, m_recvBufSize - m_recvBufInputPos);

		if (restSize > 0)
		{
			int32_t recvSize = recv(m_sock, m_recvTEABuf + m_recvTEABufInputPos, restSize, 0);

			if (recvSize < 0)
			{
				int32_t error = WSAGetLastError();

				if (error != WSAEWOULDBLOCK)
				{
					return false;
				}
			}
			else if (recvSize == 0)
			{
				return false;
			}

			m_recvTEABufInputPos += recvSize;

			int32_t decodeSize = m_recvTEABufInputPos;

			if (decodeSize >= 8)
			{
				decodeSize >>= 3;
				decodeSize <<= 3;

				int32_t decodeDstSize = tea_decrypt((uint32_t*) (m_recvBuf + m_recvBufInputPos),
												(uint32_t*) m_recvTEABuf,
												(const uint32_t*) m_szDecryptKey,
												decodeSize);

				m_recvBufInputPos += decodeDstSize;

				if (m_recvTEABufInputPos>decodeSize)
					memmove(m_recvTEABuf, m_recvTEABuf+decodeSize, m_recvTEABufInputPos-decodeSize);

				m_recvTEABufInputPos -= decodeSize;
			}
		}
	}
	else
	{
		int32_t restSize = m_recvBufSize - m_recvBufInputPos;
		if (restSize>0)
		{
			int32_t recvSize = recv(m_sock, m_recvBuf + m_recvBufInputPos, m_recvBufSize - m_recvBufInputPos, 0);

			if (recvSize < 0)
			{
				int32_t error = WSAGetLastError();

				if (error != WSAEWOULDBLOCK)
				{
					return false;
				}
			}
			else if (recvSize == 0)
			{
				return false;
			}

			m_recvBufInputPos += recvSize;
		}
	}

	return true;
}


bool CNetworkStream::__SendInternalBuffer()
{
	if (m_security_type == SECURITY_TYPE_CIPHER)
	{
		const int32_t dataSize = __GetSendBufferSize();
		if (dataSize <= 0)
			return true;

		if (IsSecurityMode())
		{
			m_cipher.Encrypt(m_sendBuf + m_sendBufOutputPos, dataSize);
		}

		const int32_t sendSize = send(m_sock, m_sendBuf + m_sendBufOutputPos, dataSize, 0);
		if (sendSize < 0)
			return false;

		m_sendBufOutputPos += sendSize;

		__PopSendBuffer();
	}
	else if(m_security_type == SECURITY_TYPE_XTEA)
	{
		int32_t encodeSize=__GetSendBufferSize();
		if (encodeSize<=0)
			return true;

		m_sendTEABufInputPos += tea_encrypt((uint32_t*) (m_sendTEABuf + m_sendTEABufInputPos),
												 (uint32_t*) (m_sendBuf + m_sendBufOutputPos),
												 (const uint32_t*) m_szEncryptKey,
												 encodeSize);
		m_sendBufOutputPos += encodeSize;

		if (m_sendTEABufInputPos>0)
		{
			int32_t sendSize = send(m_sock, m_sendTEABuf, m_sendTEABufInputPos, 0);
			if (sendSize < 0)
				return false;

			if (m_sendTEABufInputPos>sendSize)
				memmove(m_sendTEABuf, m_sendTEABuf+sendSize, m_sendTEABufInputPos-sendSize);

			m_sendTEABufInputPos-=sendSize;
		}

		__PopSendBuffer();
	}
	else
	{
		int32_t dataSize=__GetSendBufferSize();
		if (dataSize<=0)
			return true;

		int32_t sendSize = send(m_sock, m_sendBuf+m_sendBufOutputPos, dataSize, 0);
		if (sendSize < 0)
			return false;

		m_sendBufOutputPos+=sendSize;

		__PopSendBuffer();
	}

	return true;
}

void CNetworkStream::__PopSendBuffer()
{
	if (m_sendBufOutputPos <= 0)
		return;

	const int32_t sendBufDataSize = m_sendBufInputPos - m_sendBufOutputPos;

	if (sendBufDataSize > 0)
	{
		memmove(m_sendBuf, m_sendBuf + m_sendBufOutputPos, sendBufDataSize);
	}

	m_sendBufInputPos = sendBufDataSize;
	m_sendBufOutputPos = 0;
}

#pragma warning(push)
#pragma warning(disable:4127)
void CNetworkStream::Process()
{
	if (m_sock == INVALID_SOCKET)
		return;

	fd_set fdsRecv{};
	fd_set fdsSend{};

	FD_ZERO(&fdsRecv);
	FD_ZERO(&fdsSend);

	FD_SET(m_sock, &fdsRecv);
	FD_SET(m_sock, &fdsSend);

	TIMEVAL delay{};

	delay.tv_sec = 0;
	delay.tv_usec = 0;

	if (select(0, &fdsRecv, &fdsSend, nullptr, &delay) == SOCKET_ERROR)
		return;

	if (!m_isOnline)
	{
		if (FD_ISSET(m_sock, &fdsSend))
		{
			m_isOnline = true;
			OnConnectSuccess();
		}
		else if (time(nullptr) > m_connectLimitTime)
		{
			Clear();
			OnConnectFailure();
		}

		return;
	}

	if (FD_ISSET(m_sock, &fdsSend) && (m_sendBufInputPos > m_sendBufOutputPos))
	{
		if (!__SendInternalBuffer())
		{
			const int32_t error = WSAGetLastError();

			if (error != WSAEWOULDBLOCK)
			{
				OnRemoteDisconnect();
				Clear();
				return;
			}
		}
	}

	if (FD_ISSET(m_sock, &fdsRecv))
	{
		if (!__RecvInternalBuffer())
		{
			OnRemoteDisconnect();
			Clear();
			return;
		}
	}

	if (!OnProcess())
	{
		OnRemoteDisconnect();
		Clear();
	}
}
#pragma warning(pop)

void CNetworkStream::Disconnect()
{
	if (m_sock == INVALID_SOCKET)
		return;

	Clear();
}

void CNetworkStream::Clear()
{
	if (m_sock == INVALID_SOCKET)
		return;

	m_cipher.CleanUp();

	closesocket(m_sock);
	m_sock = INVALID_SOCKET;

	memset(m_szEncryptKey, 0, sizeof(m_szEncryptKey));
	memset(m_szDecryptKey, 0, sizeof(m_szDecryptKey));

	m_isOnline = false;
	m_connectLimitTime = 0;

	m_recvTEABufInputPos = 0;
	m_sendTEABufInputPos = 0;

	m_recvBufInputPos = 0;
	m_recvBufOutputPos = 0;

	m_sendBufInputPos = 0;
	m_sendBufOutputPos = 0;
}

bool CNetworkStream::Connect(const CNetworkAddress& c_rkNetAddr, int32_t limitSec)
{
	Clear();

	m_addr = c_rkNetAddr;

	m_sock = socket(AF_INET, SOCK_STREAM, 0);

	if (m_sock == INVALID_SOCKET)
	{
		Clear();
		OnConnectFailure();
		return false;
	}

	u_long arg = 1;
	ioctlsocket(m_sock, FIONBIO, &arg); // Non-blocking mode

	if (connect(m_sock, reinterpret_cast<PSOCKADDR>(&m_addr), m_addr.GetSize()) == SOCKET_ERROR)
	{
		const int32_t error = WSAGetLastError();

		if (error != WSAEWOULDBLOCK)
		{
			Clear();
			OnConnectFailure();
			return false;
		}
	}

	m_connectLimitTime = time(nullptr) + limitSec;
	return true;
}

bool CNetworkStream::Connect(uint32_t dwAddr, int32_t port, int32_t limitSec)
{
	char szAddr[256];
	{
		uint8_t ip[4]{};
		ip[0] = dwAddr & 0xff;
		dwAddr >>= 8;
		ip[1] = dwAddr & 0xff;
		dwAddr >>= 8;
		ip[2] = dwAddr & 0xff;
		dwAddr >>= 8;
		ip[3] = dwAddr & 0xff;
		dwAddr >>= 8;

		sprintf(szAddr, "%d.%d.%d.%d", ip[0], ip[1], ip[2], ip[3]);
	}

	return Connect(szAddr, port, limitSec);
}

bool CNetworkStream::Connect(const char* c_szAddr, int32_t port, int32_t /*limitSec*/)
{
	CNetworkAddress kNetAddr;
	kNetAddr.Set(c_szAddr, port);

	return Connect(kNetAddr);
}

void CNetworkStream::ClearRecvBuffer()
{
	m_recvBufOutputPos = m_recvBufInputPos = 0;
}

int32_t CNetworkStream::GetRecvBufferSize() const
{
	return m_recvBufInputPos - m_recvBufOutputPos;
}

bool CNetworkStream::Peek(int32_t size)
{
	if (GetRecvBufferSize() < size)
		return false;

	return true;
}

bool CNetworkStream::Peek(int32_t size, char* pDestBuf)
{
	if (GetRecvBufferSize() < size)
		return false;

	memcpy(pDestBuf, m_recvBuf + m_recvBufOutputPos, size);
	return true;
}

bool CNetworkStream::Recv(int32_t size)
{
	if (!Peek(size))
		return false;

	m_recvBufOutputPos += size;
	return true;
}

bool CNetworkStream::Recv(int32_t size, char* pDestBuf)
{
	if (!Peek(size, pDestBuf))
		return false;

	m_recvBufOutputPos += size;
	return true;
}

int32_t CNetworkStream::__GetSendBufferSize() const
{
	return m_sendBufInputPos - m_sendBufOutputPos;
}


bool CNetworkStream::Send(int32_t size, const char* pSrcBuf)
{
	const int32_t sendBufRestSize = m_sendBufSize - m_sendBufInputPos;
	if ((size + 1) > sendBufRestSize)
		return false;

	memcpy(m_sendBuf + m_sendBufInputPos, pSrcBuf, size);
	m_sendBufInputPos += size;

	return true;
}

bool CNetworkStream::Peek(int32_t len, void* pDestBuf)
{
	return Peek(len, static_cast<char*>(pDestBuf));
}

bool CNetworkStream::Recv(int32_t len, void* pDestBuf)
{
	return Recv(len, static_cast<char*>(pDestBuf));
}

bool CNetworkStream::SendFlush(int32_t len, const void* pSrcBuf)
{
	if (!Send(len, pSrcBuf))
		return false;

	return __SendInternalBuffer();
}

bool CNetworkStream::Send(int32_t len, const void* pSrcBuf)
{
	return Send(len, static_cast<const char*>(pSrcBuf));
}

bool CNetworkStream::IsOnline() const
{
	return m_isOnline;
}

bool CNetworkStream::OnProcess()
{
	return true;
}

void CNetworkStream::OnRemoteDisconnect()
{
}

void CNetworkStream::OnDisconnect()
{
}

void CNetworkStream::OnConnectSuccess()
{
	printf("Succeed connecting.\n");
}

void CNetworkStream::OnConnectFailure()
{
	printf("Failed to connect.\n");
}

CNetworkStream::CNetworkStream(): m_sendTEABufSize(0)
{
	m_sock = INVALID_SOCKET;
	m_security_type = SECURITY_TYPE_NONE;

	memset(m_szEncryptKey, 0, sizeof(m_szEncryptKey));
	memset(m_szDecryptKey, 0, sizeof(m_szDecryptKey));

	m_isOnline = false;
	m_connectLimitTime = 0;

	m_recvTEABuf = nullptr;
	m_recvTEABufSize = 0;
	m_recvTEABufInputPos = 0;

	m_recvBuf = nullptr;
	m_recvBufSize = 0;
	m_recvBufOutputPos = 0;
	m_recvBufInputPos = 0;

	m_sendTEABuf = nullptr;
	m_sendTEABuf = nullptr;
	m_sendTEABufInputPos = 0;

	m_sendBuf = nullptr;
	m_sendBufSize = 0;
	m_sendBufOutputPos = 0;
	m_sendBufInputPos = 0;
}

CNetworkStream::~CNetworkStream()
{
	Clear();

	if (m_sendTEABuf)
	{
		delete [] m_sendTEABuf;
		m_sendTEABuf = nullptr;
	}

	if (m_recvTEABuf)
	{
		delete [] m_recvTEABuf;
		m_recvTEABuf = nullptr;
	}

	if (m_recvBuf)
	{
		delete [] m_recvBuf;
		m_recvBuf = nullptr;
	}

	if (m_sendBuf)
	{
		delete [] m_sendBuf;
		m_sendBuf = nullptr;
	}
}

size_t CNetworkStream::Prepare(void* buffer, size_t* length)
{
	return m_cipher.Prepare(buffer, length);
}

bool CNetworkStream::Activate(size_t agreed_length, const void* buffer, size_t length)
{
	return m_cipher.Activate(true, agreed_length, buffer, length);
}

void CNetworkStream::ActivateCipher()
{
	return m_cipher.set_activated(true);
}