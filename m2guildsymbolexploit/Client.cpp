#include "pch.h"
#include "Client.h"

Client::Client()
{
	SetSecurityType(SECURITY_TYPE_NONE);

	SetRecvBufferSize(640 * 1024);
	SetSendBufferSize(640 * 1024);
	m_vecGuildIDX.clear();
}

Client::~Client()
{

}

void Client::Process()
{
	CNetworkStream::Process();

	uint8_t header;
	if (!Peek(sizeof(uint8_t), &header))
		return;

	if (IsSecurityMode())
	{
		if (0 == header)
		{
			if (!Recv(sizeof(header), &header))
				return;
			return;
		}
	}

	uint32_t needPacketSize = GetPacketSize(header);

	if (!needPacketSize)
		return;

	if (!Peek(needPacketSize))
		return;

	if (!DispatchPacket(header))
	{
		printf("Can't dispatch packet %u\n", header);
		abort();
	}
}

uint32_t Client::GetPacketSize(uint8_t header)
{
	switch (header)
	{
	case HEADER_GC_PHASE:
		return sizeof(TPacketGCPhase);

	case HEADER_GC_HANDSHAKE:
		return sizeof(TPacketGCHandshake);

	case HEADER_GC_PING:
		return sizeof(TPacketGCPing);

	case HEADER_GC_MARK_IDXLIST:
		return sizeof(TPacketGCMarkIDXList);

	case HEADER_GC_MARK_BLOCK:
		return sizeof(TPacketGCMarkBlock);

	case HEADER_GC_GUILD_SYMBOL_DATA:
		return sizeof(TPacketGCGuildSymbolData);

	case HEADER_GC_MARK_DIFF_DATA:
		return sizeof(uint8_t);
	}
	return 0;
}

bool Client::DispatchPacket(uint8_t header)
{
	switch (header)
	{
	case HEADER_GC_PHASE:
		return __RecvPhase();

	case HEADER_GC_HANDSHAKE:
		return __RecvHandshake();

	case HEADER_GC_PING:
		return __RecvPing();

	case HEADER_GC_MARK_IDXLIST:
		return __RecvMarkIndex();

	case HEADER_GC_MARK_BLOCK:
		return __RecvMarkBlock();

	case HEADER_GC_GUILD_SYMBOL_DATA:
		return __RecvSymbolData();

	case HEADER_GC_MARK_DIFF_DATA:
		return true;
	}
	return false;
}

bool Client::__RecvPhase()
{
	TPacketGCPhase kPacketPhase;
	if (!Recv(sizeof(kPacketPhase), &kPacketPhase))
		return false;

	if (kPacketPhase.phase == 2)
	{
		if (GetSecurityType() != SECURITY_TYPE_NONE) {
			const char* key = "testtesttesttest";
			SetSecurityMode(true, key);
		}

		__SendMarkIDXList();
	}

	return true;
}

bool Client::__RecvHandshake()
{
	TPacketGCHandshake kPacketHandshake;
	if (!Recv(sizeof(kPacketHandshake), &kPacketHandshake))
		return false;

	TPacketCGMarkLogin kPacketMarkLogin = {};
	kPacketMarkLogin.header = HEADER_CG_MARK_LOGIN;
	if (!Send(sizeof(kPacketMarkLogin), &kPacketMarkLogin))
		return false;

	return true;
}

bool Client::__RecvPing()
{
	return false;
}

bool Client::__RecvMarkIndex()
{
	TPacketGCMarkIDXList kPacketMarkIndex;
	if (!Peek(sizeof(kPacketMarkIndex), &kPacketMarkIndex))
		return false;

	if (!Peek(kPacketMarkIndex.bufSize))
		return false;

	if (!Recv(sizeof(kPacketMarkIndex)))
		return false;

	m_vecGuildIDX.clear();
	if (kPacketMarkIndex.count > 0)
	{

		uint16_t guildID, markID;
		for (uint16_t i = 0; i < kPacketMarkIndex.count; ++i)
		{
			if (!Recv(sizeof(uint16_t), &guildID))
				return false;

			if (!Recv(sizeof(uint16_t), &markID))
				return false;
			printf("__RecvMarkIndex: guildID %u\n", guildID);
			m_vecGuildIDX.emplace_back(guildID);
		}
	}

	if (!m_vecGuildIDX.empty())
	{
		TPacketCGMarkUpload packet = {};
		packet.header = HEADER_CG_MARK_UPLOAD;

		// white pixels
		for (uint32_t i = 0; i < 192; ++i)
			*((uint32_t*)packet.image + i) = UINT32_MAX;

		for (const auto& gid : m_vecGuildIDX)
		{
			packet.gid = gid;
			if (!Send(sizeof(packet), &packet))
			{
				printf("Can't send mark upload gid %u\n", gid);
				return false;
			}
		}
	}
	else {
		printf("No guilds ?\n");
	}

	return true;
}

bool Client::__RecvMarkBlock()
{
	return false;
}

bool Client::__RecvSymbolData()
{
	return false;
}

bool Client::__SendMarkIDXList()
{
	TPacketCGMarkIDXList kPacketMarkIDXList{};
	kPacketMarkIDXList.header = HEADER_CG_MARK_IDXLIST;
	if (!Send(sizeof(kPacketMarkIDXList), &kPacketMarkIDXList))
		return false;
	return true;
}
